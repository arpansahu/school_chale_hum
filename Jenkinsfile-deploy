pipeline {
    agent { label 'local' }
    parameters {
        booleanParam(name: 'DEPLOY', defaultValue: true, description: 'Enable deployment')
        choice(name: 'DEPLOY_TYPE', choices: ['kubernetes', 'docker'], description: 'Select deployment type')
    }
    environment {
        KUBECONFIG = "${env.WORKSPACE}/kubeconfig"  // Set the KUBECONFIG environment variable
    }
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "Current workspace path is: ${env.WORKSPACE}"
                }
            }
        }
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Setup Environment') {
            steps {
                script {
                    // Load .env from Jenkins credentials
                    withCredentials([file(credentialsId: 'school_chale_hum_env_file', variable: 'ENV_FILE')]) {
                        // Remove existing .env file if it exists (handles read-only files)
                        sh 'rm -f .env || true'
                        
                        def envContent = readFile(file: env.ENV_FILE)
                        writeFile(file: '.env', text: envContent)
                        
                        // Parse and set environment variables
                        def envVars = envContent.split('\n')
                        envVars.each { line ->
                            if (line && !line.startsWith('#') && line.contains('=')) {
                                def parts = line.split('=', 2)
                                def key = parts[0].trim()
                                def value = parts.length > 1 ? parts[1].trim() : ''
                                env."${key}" = value
                            }
                        }
                        
                        // Set derived variables
                        env.BUILD_PROJECT_NAME = "${env.ENV_PROJECT_NAME}_build"
                        env.PROJECT_NAME_WITH_DASH = env.ENV_PROJECT_NAME.replace('_', '-')
                        env.REGISTRY = env.DOCKER_REGISTRY
                        env.REPOSITORY = "${env.DOCKER_REPOSITORY}/${env.DOCKER_IMAGE_NAME}"
                        env.NGINX_CONF = "/etc/nginx/sites-available/${env.PROJECT_NAME_WITH_DASH}"
                    }
                }
            }
        }
        stage('Setup Kubernetes Config') {
            when {
                expression { return params.DEPLOY_TYPE == 'kubernetes' }
            }
            steps {
                script {
                    // Copy the kubeconfig file to the workspace
                    sh "sudo cp /root/.kube/config ${env.WORKSPACE}/kubeconfig"
                    // Change permissions of the kubeconfig file
                    sh "sudo chmod 644 ${env.WORKSPACE}/kubeconfig"
                }
            }
        }
        stage('Update Nginx Configuration') {
            steps {
                script {
                    echo "Updating Nginx configuration from repository..."

                    // Always update the config to ensure it matches the repository version
                    sh "sudo cat nginx.conf | sudo tee ${NGINX_CONF} > /dev/null"

                    // Replace placeholders in the configuration file
                    sh "sudo sed -i 's|SERVER_NAME|${SERVER_NAME}|g' ${NGINX_CONF}"
                    sh "sudo sed -i 's|DOCKER_PORT|${DOCKER_PORT}|g' ${NGINX_CONF}"

                    echo "âœ… Nginx configuration updated successfully"

                    // Ensure Nginx is aware of the configuration
                    sh "sudo ln -sf ${NGINX_CONF} /etc/nginx/sites-enabled/"
                    
                    // Test nginx configuration
                    sh "sudo nginx -t"
                }
            }
        }
        stage('Retrieve Image Tag from Build Job') {
            when {
                expression { params.DEPLOY }
            }
            steps {
                script {
                    withCredentials([usernamePassword(
                        credentialsId: 'jenkins-admin-credentials',
                        usernameVariable: 'JENKINS_USER',
                        passwordVariable: 'JENKINS_TOKEN'
                    )]) {
                        // Query Jenkins API to get the last successful build number
                        def buildJobName = "${env.ENV_PROJECT_NAME}_build"
                        def jenkinsUrl = "https://jenkins.arpansahu.space"
                        def apiUrl = "${jenkinsUrl}/job/${buildJobName}/lastSuccessfulBuild/api/json"
                        
                        echo "Querying Jenkins API: ${apiUrl}"
                        
                        def buildInfoJson = sh(
                            script: "curl -s -u ${JENKINS_USER}:${JENKINS_TOKEN} '${apiUrl}'",
                            returnStdout: true
                        ).trim()
                        
                        echo "Build info: ${buildInfoJson}"
                        
                        // Extract the build number (id) from the JSON response
                        def imageTag = sh(
                            script: """echo '${buildInfoJson}' | grep -o '"id":"[0-9]*"' | head -1 | tr -dc '0-9'""",
                            returnStdout: true
                        ).trim()
                        
                        if (!imageTag) {
                            error "Failed to retrieve image tag from build job. Build info: ${buildInfoJson}"
                        }
                        
                        echo "Retrieved image tag: ${imageTag}"
                        env.IMAGE_TAG = imageTag
                    }
                }
            }
        }
        stage('Prepare Deployment Config') {
            when {
                expression { params.DEPLOY }
            }
            steps {
                script {
                    echo "Using image tag from build job: ${env.IMAGE_TAG}"

                    // Check if REGISTRY, REPOSITORY, and IMAGE_TAG are all defined and not empty
                    if (env.REGISTRY && env.REPOSITORY && env.IMAGE_TAG) {
                        if (params.DEPLOY_TYPE == 'kubernetes') {
                            // Replace the placeholder in the deployment YAML
                            sh "sed -i 's|:latest|:${env.IMAGE_TAG}|g' ${WORKSPACE}/deployment.yaml"
                            echo "Updated deployment.yaml with image tag: ${env.IMAGE_TAG}"
                        }   
                        
                        if (params.DEPLOY_TYPE == 'docker') {
                            // Ensure the correct image tag is used in the docker-compose.yml
                            sh """
                            sed -i 's|image: .*|image: ${env.REGISTRY}/${env.REPOSITORY}:${env.IMAGE_TAG}|' docker-compose.yml
                            """
                            echo "Updated docker-compose.yml with image tag: ${env.IMAGE_TAG}"
                        }
                    } else {
                        error "Required variables (REGISTRY, REPOSITORY, IMAGE_TAG) are missing. Cannot proceed with deployment."
                    }
                }
            }
        }
        stage('Deploy') {
            when {
                expression { params.DEPLOY }
            }
            steps {
                script {
                    if (params.DEPLOY_TYPE == 'docker') {

                        sh 'docker-compose down'
                        sh 'docker-compose pull'
                        sh 'docker-compose up -d'

                        sleep 60

                        def containerRunning = sh(script: "docker ps -q -f name=${env.ENV_PROJECT_NAME}", returnStdout: true).trim()
                        if (!containerRunning) {
                            error "Container ${env.ENV_PROJECT_NAME} is not running"
                        } else {
                            echo "Container ${env.ENV_PROJECT_NAME} is running"
                            sh """
                                # Fetch HTTP status code
                                HTTP_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" -L http://0.0.0.0:${env.DOCKER_PORT})
                                echo "HTTP Status: \$HTTP_STATUS"
                                
                                # Update Nginx configuration if status code is 200 (OK)
                                if [ "\$HTTP_STATUS" -eq 200 ]; then
                                    sudo sed -i 's|proxy_pass .*;|proxy_pass http://0.0.0.0:${env.DOCKER_PORT};|' ${env.NGINX_CONF}
                                    sudo nginx -s reload
                                    echo 'Nginx configuration updated and reloaded successfully.'
                                else
                                    echo 'Service not available. Nginx configuration not updated.'
                                fi

                                # Scale down Kubernetes deployment if it exists and is running
                                replicas=\$(kubectl get deployment ${env.PROJECT_NAME_WITH_DASH}-app -o=jsonpath='{.spec.replicas}') || true
                                if [ "\$replicas" != "" ] && [ \$replicas -gt 0 ]; then
                                    kubectl scale deployment ${env.PROJECT_NAME_WITH_DASH}-app --replicas=0
                                    echo 'Kubernetes deployment scaled down successfully.'
                                else
                                    echo 'No running Kubernetes deployment to scale down.'
                                fi
                            """
                        }
                    } else if (params.DEPLOY_TYPE == 'kubernetes') {
                        // Verify Kubernetes configuration
                        sh 'kubectl cluster-info'
                            
                            // Print current directory
                            sh 'pwd'
                            
                            // Create or update secret (delete + recreate to avoid conflicts)
                            sh """
                            kubectl delete secret ${env.PROJECT_NAME_WITH_DASH}-secret --ignore-not-found=true
                            kubectl create secret generic ${env.PROJECT_NAME_WITH_DASH}-secret --from-env-file=${WORKSPACE}/.env
                            kubectl apply -f ${WORKSPACE}/service.yaml
                            kubectl apply -f ${WORKSPACE}/deployment.yaml
                            """
                            
                            // Wait for a few seconds to let the app start
                            sleep 60

                            sh """
                                kubectl describe deployment/${env.PROJECT_NAME_WITH_DASH}-app
                            """

                            // Verify service and get NodePort
                            def nodePort = sh(script: "kubectl get service ${env.PROJECT_NAME_WITH_DASH}-service -o=jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()
                            echo "Service NodePort: ${nodePort}"

                            // Get cluster IP address
                            def clusterIP = sh(script: "kubectl get nodes -o=jsonpath='{.items[0].status.addresses[0].address}'", returnStdout: true).trim()
                            echo "Cluster IP: ${clusterIP}"

                            // Verify if the service is accessible and delete the Docker container if accessible and update nginx configuration
                            sh """
                                HTTP_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" -L http://${clusterIP}:${nodePort})
                                echo "HTTP Status: \$HTTP_STATUS"
                                
                                if [ "\$HTTP_STATUS" -eq 200 ]; then
                                    echo "Service is reachable at http://${clusterIP}:${nodePort}"

                                    echo "Updating Nginx configuration at ${env.NGINX_CONF}..."
                                    sudo sed -i 's|proxy_pass .*;|proxy_pass http://${clusterIP}:${nodePort};|' ${env.NGINX_CONF}
                                    
                                    if [ \$? -ne 0 ]; then
                                        echo "Failed to update Nginx configuration"
                                        exit 1
                                    fi
                                    
                                    echo "Reloading Nginx..."
                                    sudo nginx -s reload
                                    
                                    if [ \$? -ne 0 ]; then
                                        echo "Failed to reload Nginx"
                                        exit 1
                                    fi
                                    
                                    echo "Nginx reloaded successfully"
                                    
                                    DOCKER_CONTAINER=\$(docker ps -q -f name=${env.ENV_PROJECT_NAME})
                                    
                                    if [ "\$DOCKER_CONTAINER" ]; then
                                        echo "Docker container ${env.ENV_PROJECT_NAME} is running. Removing it..."
                                        docker rm -f ${env.ENV_PROJECT_NAME}
                                        
                                        if [ \$? -ne 0 ]; then
                                            echo "Failed to remove Docker container ${env.ENV_PROJECT_NAME}"
                                            exit 1
                                        fi
                                        
                                    else
                                        echo "Docker container ${env.ENV_PROJECT_NAME} is not running. Skipping removal"
                                    fi

                                else
                                    echo "Service is not reachable at http://${clusterIP}:${nodePort}. HTTP Status: \$HTTP_STATUS"
                                    exit 1
                                fi
                            """
                    }
                    currentBuild.description = 'DEPLOYMENT_EXECUTED'
                }
            }
        }
        stage('Sentry release') {
            when {
                expression { params.DEPLOY }
            }
            steps {
                script {
                    echo "Sentry Release ..."

                    sh """
                        # Get the current git commit hash
                        VERSION=\$(git rev-parse HEAD)

                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} new \$VERSION

                        # Associate commits with the release
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} set-commits --auto \$VERSION

                        # Deploy the release (optional step for marking the release as deployed)
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} deploys \$VERSION new -e production
                    """
                }
            }
        }
    }
    post {
        success {
            script {
                if (currentBuild.description == 'DEPLOYMENT_EXECUTED') {
                    sh """curl -s \
                    -X POST \
                    --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET \
                    https://api.mailjet.com/v3.1/send \
                    -H "Content-Type:application/json" \
                    -d '{
                        "Messages":[
                                {
                                        "From": {
                                                "Email": "$MAIL_JET_EMAIL_ADDRESS",
                                                "Name": "ArpanSahuOne Jenkins Notification"
                                        },
                                        "To": [
                                                {
                                                        "Email": "$MY_EMAIL_ADDRESS",
                                                        "Name": "Development Team"
                                                }
                                        ],
                                        "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Successfully",
                                        "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed",
                                        "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                                }
                        ]
                    }'"""
                }
                // Trigger the common_readme job on success when last commit is not Automatic Update from common_readme
                def commitMessage = sh(script: "git log -1 --pretty=%B", returnStdout: true).trim()
                if (!commitMessage.contains("Automatic Update")) {
                    def expandedProjectUrl = "https://github.com/arpansahu/${env.ENV_PROJECT_NAME}"
                    build job: 'common_readme', parameters: [
                        string(name: 'project_git_url', value: expandedProjectUrl),
                        string(name: 'environment', value: 'prod')
                    ], wait: false
                } else {
                    echo "Skipping common_readme job trigger due to commit message: ${commitMessage}"
                }            
            }
        }
        failure {
            script {
                sh """curl -s \
                -X POST \
                --user $MAIL_JET_API_KEY:$MAIL_JET_API_SECRET \
                https://api.mailjet.com/v3.1/send \
                -H "Content-Type:application/json" \
                -d '{
                    "Messages":[
                            {
                                    "From": {
                                            "Email": "$MAIL_JET_EMAIL_ADDRESS",
                                            "Name": "ArpanSahuOne Jenkins Notification"
                                    },
                                    "To": [
                                            {
                                                    "Email": "$MY_EMAIL_ADDRESS",
                                                    "Name": "Developer Team"
                                            }
                                    ],
                                "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Failed",
                                "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} deployment failed",
                                "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is not deployed, Build Failed </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                            }
                    ]
                }'"""
            }
        }
    }
}